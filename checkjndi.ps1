<#PSScriptInfo

# .<help keyword> <help content>

.VERSION 1.0.2 # script version?

.GUID db424b6a-fdee-48e0-b0d5-3949e07c2ef6 # unique guid of this script? when it was created?

.AUTHOR  https://github.com/CERTCC 

.PROJECTURI https://github.com/CERTCC/CVE-2021-44228_scanner

.Description
Scans filesystem for .jar, war, and ear files that contains log4j code that may be vulnerable to CVE-2021-44228
Supply a top-level directory to begin searching, or default to the current directory.

.PARAMETER Toplevel
Top-level directory to begin search for jar files.
# (Optional argument to pass in when calling the script, starts searching from this directory if listed)

.PARAMETER Force
Allows the Get-Childitem cmdlet to get items that otherwise can't be accessed by the user, such as hidden or system files. The Force parameter doesn't override security restrictions. Implementation varies among providers. For more information, see about_Providers.
# (Optional argument to search hidden and system files)

.EXAMPLE
PS> .\checkjindi.ps1
Scan the current directory and subdirectory for jar files.

.EXAMPLE
PS> .\checkjindi.ps1 c:\
Scan the entire c:\ drive for jar files.

.SYNOPSIS
Scans filesystem for .jar files that contains log4j code that may be vulnerable to CVE-2021-44228.
#>

#### End of comment



###
# MOdified by alex pena
# Sources:
# https://stackoverflow.com/questions/24649019/how-to-use-confirm-in-powershell/24649481
# https://www.reddit.com/r/PowerShell/comments/8ixnbz/using_writeprogress_while_obtaining_data_using/




[CmdletBinding()] # Turns function into advanced function (able to pipe data in, etc.)
param (
    # Specifies a path to one or more locations.
    [Parameter(Mandatory=$false, # parameter is not required (because default path is curr directory)
               Position=0, # If parameter name is not used (ex. -Path), then must use pos 0
               ParameterSetName="Path", # Parameter name to use when calling script (./script.ps1 -Path "C:..")
               ValueFromPipeline=$true, # Parameter accepts input from a pipeline object
               ValueFromPipelineByPropertyName=$true, # The piped object has a property of the same name as the parameter?
               HelpMessage="Path to one or more locations.")] #displayed when mandatory param is missing
    [Alias("PSPath")] # Alternate name for parameter
    [ValidateNotNullOrEmpty()] # Parameter can't be null or empty string
    [string[]] # Takes an array of strings as input?
    $toplevel = ".", # parameter by default is caled "toplevel", and is set to "." (current dir) by default
    #[string]$toplevel = ".", 
    [switch] $Force = $false # parameter of type switch, it's called Force, and its by default set to false
    )
# Sets to require powershell major version 3 or higher
#Requires -Version 3.0 

# Begin - First script block, optional, only called once
Begin {
    Add-Type -Assembly 'System.IO.Compression.FileSystem' # Adding .NET classes from the assembly. This is used for zipping.
    $global:foundvulnerable = $false # global variable, set to false
    


    $global:filepath = "./warnings.txt" # Log file for log4j warnings to be copied to


    if (Test-Path -Path $global:filepath -PathType Leaf) # If the warning file with same name already exists
    {
        $title    = "Output file for warnings `"$global:filepath`" already exists"
        $question = "Overwrite `"$global:filepath`"?"
        $choices  = '&Yes', '&No'

        $decision = $Host.UI.PromptForChoice($title, $question, $choices, 1)
        if ($decision -eq 0) {
            Clear-Content $global:filepath # Clear the warnings file
        } else {
            while (Test-Path -Path $global:filepath -PathType Leaf)
            {
                $random = Get-Random
                $global:filepath = "./warnings_" + $random + ".txt"
            }
        }
    }

    Write-Verbose "Writing warnings to file $global:filepath"

    Start-Sleep -Seconds 1.5

    # Clear-Host

    ##### Defines the functions which we will use later
    ##### - And gives a warning if "-Force" not used

    # When called, the top level directory is passed in as a paramter
    function Get-Files {
        # Defines the paramter passed in 
        param (
            [string]$topdir #string of the top level directory to scan
        )

            # Gets items at "$topdir" directory. 
            # - Path --->   defines the path/directory to begin searching
            # - File --->   specifies that we are getting/searching for a list of files
            # - Recurse-->  gets items at location and all child item at that location
            # - Force --->  hidden and sys files can be scanned if true
            # - Include ->  array of one or more string patters to be matched as cmdlet gets child items. (which files to include)
            ##############  - So here, we are including any type of possibly vulnerable file
            # - ErrorAction-> Specifies action to take on errror
            # - ErrorVariable-> Error is assigned to variable name provided ("UnscannablePaths" in this case)

            ## Write-Host "before getchilditem"

            # Get all items of a certain type at a specified directory
            ## This just gets the names of all the files we want, not the files themselves
            ### ***** This is the command that takes the longest it is looking like!!! **** 
            ## Get-ChildItem -Path $topdir -File -Recurse -Force:$Force -Include "*.jar","*.war","*.ear","*.zip","JndiLookup.class" -ErrorAction SilentlyContinue -ErrorVariable UnscannablePaths

            $counter = 0

            Get-ChildItem -Path $topdir -File -Recurse -Force:$Force `
                -Include "*.jar","*.war","*.ear","*.zip","JndiLookup.class" `
                -ErrorAction SilentlyContinue -ErrorVariable UnscannablePaths | 
                ForEach-Object {
                    Write-Verbose "Fetching file: $_.fullname"; 
                    $counter++;
                    Write-Progress -Activity "Fetching files..." -Status "Fetched $counter files" -PercentComplete -1;
                    $_
                }



                # [System.Collections.ArrayList]$MyFiles = @()
                # Get-ChildItem -Path C:\ -Filter *.txt -Recurse -ErrorAction SilentlyContinue| % {
                #     [void]$MyFiles.Add($_)
                #     Write-Progress -Activity "Searching for Text files recursively" -Status $_.Directory -CurrentOperation ("Files Collected: {0:N0}" -f $MyFiles.Count) -PercentComplete -1
                # }

            # The resulting files are stored in the output stream after this I beleive

            # For each error with unscannable path (because it can be an array/list of errors)
            foreach ($Exception in $UnscannablePaths) {
                # Write the warning to the user about the object and the error that occured
                Write-Warning "Unable to scan $($Exception.TargetObject) : $($Exception.FullyQualifiedErrorID)"
            }
    }
    
    function Open-JAR {
        # Arguments that are passed into the function
        param (
            [Object]$jarfile, # The jar/zipped file passed in to the fucntion
            [String]$origfile = "", # Used within recursive calls --> 
            [String]$subjarfile = "" # Used within recurseive calls -->
        )

        # Attempt to open a zipped file
        try {
            # Stores the stream which represents the contents of the zip in $jar
            $jar = [System.IO.Compression.ZipFile]::Open($jarfile, 'read');
        }

        # If error occurs while attempting to unzip, show error and stop
        catch {
            Write-Warning "Unable to scan $jarfile : $($_.FullyQualifiedErrorID)" 
            return
        }


        [bool] $ispatched = 0;
        [bool] $hasjndi = 0;
        [string] $outputstring = "";

        # Write-Verbose "Scanning compressed file [$jarfile]"
    
        # Loop through each entry/file in the zip
        ForEach ($entry in $jar.Entries) {
            # Write-Output $entry.Name;
            ## Write-Verbose $entry.Name

            # If the file name is the JnddiLookup.class
            if($entry.Name -like "*JndiLookup.class"){
                # If this file is in the top level of the zip being openeed
                if ($origfile -eq "")
                {
                    # Flag that jndi is used
                    $hasjndi = 1;
                    $outputstring = "$jarfile contains $entry";
                }
                else # If the file has been found in a zip within the zipped file
                {
                    # Flag
                    $hasjndi = 1;
                    $outputstring = "$origfile contains $subjarfile contains $entry";
                }

                # ?
                $TempFile = [System.IO.Path]::GetTempFileName()
                
                # Attempt to extract the zipped content we opened, into the temp file
                try {
                    # Write-Verbose "Scanning $entry in $jarfile" 
                    [System.IO.Compression.ZipFileExtensions]::ExtractToFile($entry, $TempFile, $true); # Extracting the current file to the temp file?
                   
                    # ??????????????????????
                    if (Select-String -Path $TempFile -Pattern "JNDI is not supported"){
                        $ispatched = 1;
                    }
                }
                catch {
                    Write-Warning "Unable to scan $entry in $jarfile : $($_.FullyQualifiedErrorID)" 
                }
                Remove-Item $TempFile;
            }
            elseif ($entry.Name -like "*MessagePatternConverter.class"){
                $TempFile = [System.IO.Path]::GetTempFileName()
                try {
                    [System.IO.Compression.ZipFileExtensions]::ExtractToFile($entry, $TempFile, $true);
                    if (Select-String -Path $TempFile -Pattern "Message Lookups are no longer supported"){
                        $ispatched = 1;
                    }
                }
                catch {
                    Write-Warning "Unable to scan $entry in $jarfile : $($_.FullyQualifiedErrorID)" 
                }
                Remove-Item $TempFile;
            }
            elseif (($entry.Name -like "*.jar") -or ($entry.Name -like "*.war") -or ($entry.Name -like "*.ear") -or ($entry.Name -like "*.zip")) {
                if ($origfile -eq "")
                {
                    $origfile = $jarfile.FullName
                }
                $TempFile = [System.IO.Path]::GetTempFileName()
                try {
                    [System.IO.Compression.ZipFileExtensions]::ExtractToFile($entry, $TempFile, $true);
                    Open-JAR $TempFile $origfile $entry.FullName;
                }
                catch{
                    Write-Warning "Unable to scan $entry in $jarfile : $($_.FullyQualifiedErrorID)" 
                }
                Remove-Item $TempFile;
    
            }
        }

        $jar.Dispose();
        if ($ispatched){
            $outputstring = $outputstring + " ** BUT APPEARS TO BE PATCHED **";
        }
        if ($hasjndi -and $ispatched){
            Write-Host $outputstring;
            
            ## My addition
            Add-Content $global:filepath "$outputstring"
        }
        elseif ($hasjndi){
            $global:foundvulnerable = $true
            Write-Warning $outputstring;
            Write-Warning $outputstring 3>> $global:filepath;
        }
    
    }

    if (-not $Force) {
        Write-Warning "-Force not used, will not scan System or Hidden files."
    }
    
}

# The main part of the script/function. Not optional in this case, as we are set to accept pipeline input. Process gets called once for each pipeline input object
Process {
    Write-Verbose "## Fetching files from $toplevel ##" # Debugging messages when "-Verbose" switch is passed to cmdlet. Prints the directory to scan

    $checkfiles = Get-Files $toplevel; # Call our defined function "Get-Files", passing in the top level directory
    
    Write-Verbose "`n`n"
    
    $i = 0

    Write-Verbose "## Scanning $toplevel ##" # Debugging messages when "-Verbose" switch is passed to cmdlet. Prints the directory to scan
    ForEach ($checkfile In $checkfiles) { # Loop through each path/filename we found using the "Get-Files" command
    
        Write-Verbose "Scanning: [$toplevel] - $checkfile" # try and print out each file scanning
        
        if ($checkfile.Name -eq "JndiLookup.class")
        {
            Write-Host "$checkfile *IS* JndiLookup.class" 
            
            ## My addition
            Add-Content $global:filepath "$checkfile *IS* JndiLookup.class" 

        }
        else # If the file is any type of compressed file, call our function to process it
        {
            Open-JAR $checkfile;
        }

        $i++
        Write-Progress -Activity "Scanning files..." -Status "Scanned : $i of $($checkfiles.Count)" `
            -PercentComplete (($i / $checkfiles.Count) * 100)
    }

    Start-Sleep -Seconds 1.5
}

# Ending part of the script block, only called once. One tine post processing
End {

    # If no vulnerabilities found, then print message accordingly
    "`n`n"
    Add-Content $global:filepath "`n`n"

    if ($global:foundvulnerable -eq $false) {
        Write-Host "No vulnerable components found"

        ## My addition
        Add-Content $global:filepath "No vulnerable components found"
        
    }
    else {
        Write-Warning "***** Vulnerable Components Found! *****"
        Write-Warning "***** Vulnerable Components Found! *****" 3>> $global:filepath
    }
    
}