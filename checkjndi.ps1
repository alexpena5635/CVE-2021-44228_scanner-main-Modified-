<#PSScriptInfo

.VERSION 2

.GUID db424b6a-fdee-48e0-b0d5-3949e07c2ef6

.ORIGAUTHOR  https://github.com/CERTCC ###### Modified by Alex Pena https://github.com/alexpena5635/CVE-2021-44228_scanner-main-Modified-

.ORIGPROJECTURI https://github.com/CERTCC/CVE-2021-44228_scanner

.SOURCE
    https://stackoverflow.com/questions/24649019/how-to-use-confirm-in-powershell/24649481
    https://www.reddit.com/r/PowerShell/comments/8ixnbz/using_writeprogress_while_obtaining_data_using/
    https://stackoverflow.com/a/69036020 ### Massive improvements in speed


.Description
Scans filesystem for .jar, war, and ear files that contains log4j code that may be vulnerable to CVE-2021-44228
Supply a top-level directory to begin searching, or default to the current directory.

.PARAMETER Toplevel
Top-level directory to begin search for jar files.

.PARAMETER Force
Allows the Get-Childitem cmdlet to get items that otherwise can't be accessed by the user, such as hidden or system files. The Force parameter doesn't override security restrictions. Implementation varies among providers. For more information, see about_Providers.

.EXAMPLE
PS> .\checkjindi.ps1
Scan the current directory and subdirectory for jar files.

.EXAMPLE
PS> .\checkjindi.ps1 c:\
Scan the entire c:\ drive for jar files.

.SYNOPSIS
Scans filesystem for .jar files that contains log4j code that may be vulnerable to CVE-2021-44228.
#>


[CmdletBinding()] # Advanced function
param (
    # Specifies a path to one or more locations.
    [Parameter(Mandatory=$false, 
               Position=0, # If parameter name is not used (ex. -Path), then must use pos 0
               ParameterSetName="Path", # Parameter name to use when calling script (./script.ps1 -Path "C:..")
               ValueFromPipeline=$true, 
               ValueFromPipelineByPropertyName=$true, 
               HelpMessage="Path to one or more locations.")]
    [Alias("PSPath")]
    [ValidateNotNullOrEmpty()] # Parameter cannot be null or empty string
    [string[]]
    $toplevel = ".", # path is current dir by default
    [switch] $Force = $false
    )

#Requires -Version 3.0 


Begin {
    <# Setup #>
    Add-Type -Assembly 'System.IO.Compression.FileSystem' 

    # Set to true when any unpacthed vulnerabilitiy is found
    $global:foundvulnerable = $false
    
    # Log file for log4j warnings to be copied to
    $global:current = Get-Location 
    $global:filepath = "./warnings.txt"
    $global:errorpath = "./errors.txt"
    Clear-Content $global:errorpath

    # If the log file already exists, ask user if want to overwrite
    if (Test-Path -Path $global:filepath -PathType Leaf)
    {
        $message    = "Output file for warnings `"$global:filepath`" already exists"
        $prompt = "Overwrite `"$global:filepath`"?"
        $choices  = '&Yes', '&No'

        $decision = $Host.UI.PromptForChoice($message, $prompt, $choices, 1)
        if ($decision -eq 0) # Overwrite the exisiting file, clear it
        {  
            Clear-Content $global:filepath
        } 
        else # Create a new log file
        { 
            while (Test-Path -Path $global:filepath -PathType Leaf)
            {
                $random = Get-Random
                $global:filepath = "./warnings_" + $random + ".txt"
            }
        }
    }

    Write-Verbose "Current Directory: $global:current"
    Write-Verbose "Writing warnings to file $global:filepath"
    Write-Verbose "Writing errors to file $global:errorpath"
    Start-Sleep -Seconds 1.5

    <# Function Defintions #>
    function Search-Files {
        param (
            [string]$topdir # String of top level directory to scan
        )

        # Number of files scanned
        $counter = 0

        # Get all files and subfiles
        Get-ChildItem -Path $topdir -File -Recurse -Force:$Force -ErrorAction SilentlyContinue -ErrorVariable UnscannablePaths      |  # Pass all file names
        Where-Object { ($_.extension -match '\.(jar?|war?|ear?|zip?)$') -or ($_.name -eq "JndiLookup.class")}                       |  # Only keep relavent filenames
        ForEach-Object { 
            Write-Verbose "Scanning file: $($_.FullName)";
            # if ($_.fullname -eq "JndiLookup.class") # NEWEST CHANGE
            # If the file is JndiLookup
            if ($_.name -eq "JndiLookup.class") 
            {
                Write-Host "$($_.fullname) *IS* JndiLookup.class" 
                Add-Content $global:filepath "$_ *IS* JndiLookup.class"             
            }
            else # The file is compressed, pass it decompress
            {
                Open-JAR $_.FullName ; # Pass in the full filepath, not just the exact filename
            }
            
            $counter++;
            Write-Progress -Activity "Fetching and Scanning Files..." -Status "Scaned $counter files" -PercentComplete -1;
            # $_ # Pass the object on, I don't think we need this
        }

        # For each error with unscannable path (because it can be an array/list of errors)
        foreach ($Exception in $UnscannablePaths) {
            # Write the warning to the user about the object and the error that occured
            Write-Warning "Unable to scan $($Exception.TargetObject) : $($Exception.FullyQualifiedErrorID)"
            Write-Warning "Unable to scan $($Exception.TargetObject) : $($Exception.FullyQualifiedErrorID)" 3>> $global:errorpath;
        }
    }
    
    function Open-JAR {
        param (
            [Object]$jarfile, 
            [String]$origfile = "", 
            [String]$subjarfile = ""
        )

        # Attempt to open the zipped file
        try {
            $jar = [System.IO.Compression.ZipFile]::Open($jarfile, 'read');
        }
        catch {
            Write-Warning "Unable to scan $jarfile : $($_.FullyQualifiedErrorID)" 
            Write-Warning "Unable to scan $jarfile : $($_.FullyQualifiedErrorID)" 3>> $global:errorpath;
            return
        }


        [bool] $ispatched = 0;
        [bool] $hasjndi = 0;
        [string] $outputstring = "";

        # Loop through each entry/file in the zip
        ForEach ($entry in $jar.Entries) {
            # Write-Verbose $entry.Name

            # The file IS JndiLookup.class
            if($entry.name -like "*JndiLookup.class")
            {
                if ($origfile -eq "")
                {
                    $hasjndi = 1;
                    $outputstring = "$jarfile contains $entry";
                }
                else
                {
                    $hasjndi = 1;
                    $outputstring = "$origfile contains $subjarfile contains $entry";
                }

                $TempFile = [System.IO.Path]::GetTempFileName()
                # Attempt to extract the zipped content we opened, into the temp file
                try {
                    Write-Verbose "Scanning $entry in $jarfile"
                    [System.IO.Compression.ZipFileExtensions]::ExtractToFile($entry, $TempFile, $true);
                   
                    if (Select-String -Path $TempFile -Pattern "JNDI is not supported"){
                        # 2.12.2 is patched
                        # https://github.com/apache/logging-log4j2/commit/70edc233343815d5efa043b54294a6fb065aa1c5#diff-4fde33b59714d0691a648fb2752ea1892502a815bdb40e83d3d6873abd163cdeR37
                        $ispatched = 1;
                    }
                }
                catch {
                    Write-Warning "Unable to scan $entry in $jarfile : $($_.FullyQualifiedErrorID)" 
                    Write-Warning "Unable to scan $entry in $jarfile : $($_.FullyQualifiedErrorID)" 3>> $global:errorpath;
                    
                }
                Remove-Item $TempFile;
            }
            # Uses a MessagePatternConverter, indicates patched version
            elseif ($entry.Name -like "*MessagePatternConverter.class")
            {
                $TempFile = [System.IO.Path]::GetTempFileName()
                try {
                    [System.IO.Compression.ZipFileExtensions]::ExtractToFile($entry, $TempFile, $true);
                    if (Select-String -Path $TempFile -Pattern "Message Lookups are no longer supported"){
                        # 2.16 is patched
                        # https://github.com/apache/logging-log4j2/commit/27972043b76c9645476f561c5adc483dec6d3f5d#diff-22ae074d2f9606392a3e3710b34967731a6ad3bc4012b42e0d362c9f87e0d65bR97
                        $ispatched = 1;
                    }
                }
                catch {
                    Write-Warning "Unable to scan $entry in $jarfile : $($_.FullyQualifiedErrorID)" 
                    Write-Warning "Unable to scan $entry in $jarfile : $($_.FullyQualifiedErrorID)" 3>> $global:errorpath;
                    
                }
                Remove-Item $TempFile;
            }
            # File is compressed, and is nested
            # elseif (($entry.Name -like "*.jar") -or ($entry.Name -like "*.war") -or ($entry.Name -like "*.ear") -or ($entry.Name -like "*.zip")) 
            elseif ($entry.name -match '\.(jar?|war?|ear?|zip?)$') 
            {
                if ($origfile -eq "")
                {
                    $origfile = $jarfile # Recurse the nested archive
                }
                $TempFile = [System.IO.Path]::GetTempFileName()

                # Decompress the file, and recursively call Open-JAR
                try {
                    [System.IO.Compression.ZipFileExtensions]::ExtractToFile($entry, $TempFile, $true);
                    Open-JAR $TempFile $origfile $entry.FullName;
                }
                catch{
                    Write-Warning "Unable to scan $entry in $jarfile : $($_.FullyQualifiedErrorID)" 
                    Write-Warning "Unable to scan $entry in $jarfile : $($_.FullyQualifiedErrorID)" 3>> $global:errorpath;
                }
                Remove-Item $TempFile;
            }
        }

        $jar.Dispose();
        if ($ispatched){
            $outputstring = $outputstring + " ** BUT APPEARS TO BE PATCHED **";
        }
        if ($hasjndi -and $ispatched){
            Write-Host $outputstring;
            Add-Content $global:filepath "$outputstring"
        }
        elseif ($hasjndi){
            $global:foundvulnerable = $true
            Write-Warning $outputstring;
            Write-Warning $outputstring 3>> $global:filepath;
        }
    
    }

    if (-not $Force) {
        Write-Warning "-Force not used, will not scan System or Hidden files."
    }
    
}

Process {
    Search-Files $toplevel
    Start-Sleep -Seconds 1.5
}


End {
    "`n`n"
    Add-Content $global:filepath "`n`n"

    if ($global:foundvulnerable -eq $false) {
        Write-Host "No vulnerable components found"
        Add-Content $global:filepath "No vulnerable components found"
    }
    else {
        Write-Warning "***** Vulnerable Components Found! *****"
        Write-Warning "***** Vulnerable Components Found! *****" 3>> $global:filepath
    }
}



### FIX::::

#### DirUnathoruizedAccesError   --- Lots of these get fixed by running as system, but how? Dont want to do task scheduler every time. Here we go!


#### Invalid data exception


#### File not found error  ----> Fixed I think ---> I was not using the full path/name of files, only their local names. Should be fixed now. 